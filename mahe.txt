#include <iostream>
#include <thread>
#include <stop_token>
#include <SFML/Window.hpp>
#include <SFML/Graphics.hpp>
#include <vector>
#include <memory>
#include <cstdlib>
#include <cmath>

const float position_feu_critique1 = 275.0f;
const float position_feu_critique_vertical1 = 310.0f;
const float position_feu_critique_vertical2 = 455.0f;
const float position_feu_critique2 = 500.0f;
const float distance_securite = 50.0f;

static const sf::Color Orange(255, 165, 0);

enum class Traffic_color { green, orange, red };

Traffic_color operator++(Traffic_color& c) {
    c = static_cast<Traffic_color>((static_cast<int>(c) + 1) % 3);
    return c;
}

class Traffic_light {
    Traffic_color color_;
public:
    explicit Traffic_light(Traffic_color color) : color_(color) {}
    void operator++() { ++color_; }
    Traffic_color get_color() const { return color_; }
    static const sf::Color& get_SFML_color(Traffic_color color) {
        static const sf::Color colors[] = { sf::Color::Green, Orange, sf::Color::Red };
        return colors[static_cast<int>(color)];
    }
};

enum class Direction {
    Haut, Bas, Gauche, Droite
};

class Usager {
protected:
    int id_;
    float position_, position_y_; // Positions sur l'axe X et Y
    float vitesse_, vitesse_initiale_;
    bool direction_droite_; // true = droite ou bas, false = gauche ou haut

public:
    sf::Sprite sprite;
    Direction direction;

    Usager(int id, float vitesse, bool direction_droite = true, Direction dir = Direction::Droite)
        : id_(id), position_(0), position_y_(0),
        vitesse_(vitesse), vitesse_initiale_(vitesse),
        direction_droite_(direction_droite), direction(dir) {}

    bool get_direction_droite() const { return direction_droite_; }

    virtual void deplacer(float dt) {

        // Gestion des déplacements
        switch (direction) {
        case Direction::Droite:
            position_ += vitesse_ * dt;
            break;
        case Direction::Gauche:
            position_ -= vitesse_ * dt;
            break;
        case Direction::Haut:
            position_y_ -= vitesse_ * dt;
            break;
        case Direction::Bas:
            position_y_ += vitesse_ * dt;
            break;
        }
    }

    void ralentir_progressivement() { vitesse_ = vitesse_initiale_ / 2; }
    void restaurer_vitesse() { vitesse_ = vitesse_initiale_; }
    void arreter() { vitesse_ = 0; }
    virtual bool est_vertical() const = 0; // Méthode virtuelle pure

    virtual sf::Color get_color() const = 0;

    // Accesseurs pour les positions
    float get_position() const { return position_; }      // Axe X
    float get_y_position() const { return position_y_; }// Axe Y, doit être redéfini dans les classes filles

    int get_id() const { return id_; }
    float get_vitesse() const { return vitesse_; }

    virtual ~Usager() = default;
};

class UsagerBasVersHaut : public Usager {
public:
    UsagerBasVersHaut(int id) : Usager(id, 15.0f, false, Direction::Haut) {
        position_ = 430.0f; // Position de départ sur l'axe X
        position_y_ = 600.0f; // Position de départ en bas de l'écran
    }
    sf::Color get_color() const override { return sf::Color::Green; }
    bool est_vertical() const override { return true; }
};

class UsagerHautVersBas : public Usager {
public:
    UsagerHautVersBas(int id) : Usager(id, 15.0f, true, Direction::Bas) {
        position_ = 350.0f; // Position de départ sur l'axe X
        position_y_ = 0.0f; // Position de départ en haut de l'écran
    }
    sf::Color get_color() const override { return sf::Color::Cyan; }
    bool est_vertical() const override { return true; }
};

class UsagerDroitVersGauche : public Usager {
public:
    UsagerDroitVersGauche(int id) : Usager(id, 15.0f, false, Direction::Gauche) {
        position_ = 850.0f;  // Position de départ à droite
        position_y_ = 220.0f; // Position verticale de départ
    }
    sf::Color get_color() const override { return sf::Color::Magenta; }
    bool est_vertical() const override { return false; }
    
};

class Cycliste : public Usager {
public:
    Cycliste(int id) : Usager(id, 15.0f, true, Direction::Droite) {
        position_y_ = 360.0f; // Position Y pour les cyclistes
    }
    sf::Color get_color() const override { return sf::Color::Yellow; }
    bool est_vertical() const override { return false; }
};

class Pieton : public Usager {
public:
    Pieton(int id) : Usager(id, 10.0f, true, Direction::Droite) {
        position_y_ = 320.0f; // Position Y pour les piétons
    }
    sf::Color get_color() const override { return sf::Color::Red; }
    bool est_vertical() const override { return false; }
   
};

class VehiculeLeger : public Usager {
public:
    VehiculeLeger(int id) : Usager(id, 23.0f, true, Direction::Droite) {
        position_y_ = 370.0f; // Position Y pour les véhicules légers
    }
    sf::Color get_color() const override { return sf::Color::White; }
    bool est_vertical() const override { return false; }
    
};

class Bus : public Usager {
public:
    Bus(int id) : Usager(id, 15.0f, true, Direction::Droite) {
        position_y_ = 420.0f; // Position Y pour les bus
    }
    sf::Color get_color() const override { return sf::Color::Blue; }
    bool est_vertical() const override { return false; }
    
};


void dessiner_usagers(sf::RenderWindow& window, const std::vector<std::unique_ptr<Usager>>& usagers) {
    for (const auto& usager : usagers) {
        if (usager) {
            // Créer un cercle pour dessiner l'usager
            sf::CircleShape shape(10);
            shape.setFillColor(usager->get_color());

            // Pour l'axe horizontal (X)
            float x = usager->get_position(); // Position X
            float y = usager->get_y_position(); // Position Y (verticale)
            
            shape.setPosition(x, y); // Position classique pour les usagers horizontaux

            // Dessiner l'usager sur la fenêtre
            window.draw(shape);
        }
    }
}



void dessiner_feu(sf::RenderWindow& window, float x, float y, const Traffic_light& feu) {
    sf::CircleShape shape(15);
    shape.setFillColor(Traffic_light::get_SFML_color(feu.get_color()));
    shape.setPosition(x, y);
    window.draw(shape);
}

void dessiner_fond(sf::RenderWindow& window, sf::Sprite& sprite) {
    window.draw(sprite);
}

/*void gestion_feux(Traffic_light& feu, std::stop_token stop_token) {
    while (!stop_token.stop_requested()) {
        std::this_thread::sleep_for(std::chrono::seconds(5));
        ++feu;
    }
}*/

void gestion_feux_synchro(Traffic_light& feu_horizontal, Traffic_light& feu_vertical, std::stop_token stop_token) {
    while (!stop_token.stop_requested()) {
        // Les feux horizontaux passent au vert, les verticaux au rouge
        feu_horizontal = Traffic_light(Traffic_color::green);
        feu_vertical = Traffic_light(Traffic_color::red);

        std::this_thread::sleep_for(std::chrono::seconds(5)); // Durée pour les feux verts

        // Les feux horizontaux passent à l'orange
        feu_horizontal = Traffic_light(Traffic_color::orange);
        std::this_thread::sleep_for(std::chrono::seconds(2)); // Durée pour les feux orange

        // Les feux horizontaux passent au rouge, les verticaux au vert
        feu_horizontal = Traffic_light(Traffic_color::red);
        feu_vertical = Traffic_light(Traffic_color::green);
        std::this_thread::sleep_for(std::chrono::seconds(5)); // Durée pour les feux verts

        // Les feux verticaux passent à l'orange
        feu_vertical = Traffic_light(Traffic_color::orange);
        std::this_thread::sleep_for(std::chrono::seconds(2)); // Durée pour les feux orange
    }
}

void gestion_usager(Usager& usager, Traffic_light& feu, std::stop_token stop_token,
    const std::vector<std::unique_ptr<Usager>>& usagers) {
    while (!stop_token.stop_requested()) {
        bool proche_autre_usager = false;

        // Vérification des distances avec les autres usagers, en fonction de la direction de l'usager
        if (usager.get_direction_droite()) {
            // Usager venant de la droite vers la gauche, vérifier uniquement les usagers venant aussi de la droite
            if (usager.get_position() > position_feu_critique1 - 100) {  // Vérification uniquement proche du feu
                for (const auto& autre : usagers) {
                    if (autre.get() != &usager && autre->get_direction_droite()) {  // Vérifier la même direction
                        float distance = std::abs(usager.get_position() - autre->get_position());
                        if (distance < distance_securite) {
                            if (autre->get_vitesse() == 0) { // L'autre usager est arrêté
                                usager.arreter();
                                if (feu.get_color() == Traffic_color::green && usager.get_vitesse() == 0) {
                                    // Feu vert et le véhicule est arrêté -> redémarrer
                                    usager.restaurer_vitesse();
                                }
                            }
                            else {
                                usager.ralentir_progressivement();
                            }
                            proche_autre_usager = true;
                            break;
                        }
                    }
                }
            }
        }
        else {
            // Usager venant de la gauche vers la droite, vérifier uniquement les usagers venant aussi de la gauche
            if (usager.get_position() < position_feu_critique2 + 100) {  // Vérification uniquement proche du feu
                for (const auto& autre : usagers) {
                    if (autre.get() != &usager && !autre->get_direction_droite()) {  // Vérifier la même direction
                        float distance = std::abs(usager.get_position() - autre->get_position());
                        if (distance < distance_securite) {
                            if (autre->get_vitesse() == 0) { // L'autre usager est arrêté
                                usager.arreter();
                                if (feu.get_color() == Traffic_color::green && usager.get_vitesse() == 0) {
                                    // Feu vert et le véhicule est arrêté -> redémarrer
                                    usager.restaurer_vitesse();
                                }
                            }
                            else {
                                usager.ralentir_progressivement();
                            }
                            proche_autre_usager = true;
                            break;
                        }
                    }
                }
            }
        }
        // Ralentissement ou arrêt pour les usagers venant de la droite (zone proche de position_feu_critique1)
        if (usager.get_direction_droite() && usager.get_position() >= position_feu_critique1 - 30 && usager.get_position() <= position_feu_critique1) {
            if (feu.get_color() == Traffic_color::red) {
                // Calcul de la distance dynamique en fonction des usagers déjà arrêtés
                float distance_ralentissement = 30.0f; // Valeur de base
                for (const auto& autre_usager : usagers) {
                    if (autre_usager.get() != &usager && autre_usager->get_direction_droite()) { // Vérifier la même direction
                        float distance_au_feu = position_feu_critique1 - autre_usager->get_position();
                        if (distance_au_feu < 10.0f && autre_usager->get_vitesse() == 0) {
                            distance_ralentissement += 10.0f; // Augmenter la distance si un usager est arrêté très près du feu
                        }
                    }
                }

                // Vérification si le véhicule est dans la zone de ralentissement
                float distance_au_feu = position_feu_critique1 - usager.get_position();
                if (distance_au_feu <= distance_ralentissement && usager.get_vitesse() > 0) {
                    // Ralentissement progressif
                    usager.ralentir_progressivement();
                }

                // Arrêt complet si trop proche du feu
                if (distance_au_feu <= 10.0f) {
                    usager.arreter();
                }
            }
            else if (feu.get_color() == Traffic_color::orange) {
                // Ralentir seulement si proche du feu
                float distance_au_feu = position_feu_critique1 - usager.get_position();
                if (distance_au_feu <= 30.0f) {
                    usager.ralentir_progressivement();
                }
            }
            else if (feu.get_color() == Traffic_color::green) {
                // Redémarrer tous les véhicules arrêtés au feu vert
                if (usager.get_vitesse() == 0) {
                    usager.restaurer_vitesse();
                }
            }
        }

        // Ralentissement ou arrêt pour les usagers venant de la gauche (zone proche de position_feu_critique2)
        if (!usager.get_direction_droite() && usager.get_position() <= position_feu_critique2 + 30 && usager.get_position() >= position_feu_critique2) {
            if (feu.get_color() == Traffic_color::red) {
                usager.arreter();  // L'usager doit s'arrêter s'il est proche du feu
            }
            else if (feu.get_color() == Traffic_color::orange) {
                // Ralentir s'il est proche du feu
                float distance_au_feu = position_feu_critique2 - usager.get_position();
                if (distance_au_feu <= 30.0f) {
                    usager.ralentir_progressivement();
                }
            }
            else if (feu.get_color() == Traffic_color::green) {
                if (usager.get_vitesse() == 0) {
                    usager.restaurer_vitesse();  // Redémarrer au feu vert
                }
            }
        }

        // En dehors des zones critiques, restaurer la vitesse si aucun ralentissement n'est en cours
        if (!proche_autre_usager && feu.get_color() != Traffic_color::red) {
            usager.restaurer_vitesse();
        }

        // Position des feux critiques
        int position_feu_critique_vertical1y = 120;
        int position_feu_critique_vertical2y = 440;
        float distance_securite = 20.0f; // Distance de sécurité à maintenir

        // Déplacement de l'usager
        if (auto* usager_hv = dynamic_cast<UsagerHautVersBas*>(&usager)) {
            // Vérification de la position par rapport aux feux critiques verticaux
            if (usager_hv->get_y_position() == position_feu_critique_vertical1y - 30.0f && usager_hv->get_y_position() < position_feu_critique_vertical1y) {
                // Si le feu est rouge ou orange, l'usager doit s'arrêter
                if (feu.get_color() == Traffic_color::green || feu.get_color() == Traffic_color::orange) {
                    usager_hv->arreter();  // Arrêt immédiat
                    if ((feu.get_color() == Traffic_color::red || feu.get_color() == Traffic_color::orange) && usager.get_vitesse() == 0) {
                        // Feu vert et le véhicule est arrêté -> redémarrer
                        usager.restaurer_vitesse();
                    }
                }
                // Si le feu est vert, l'usager peut redémarrer
                else {
                    usager_hv->restaurer_vitesse();  // Redémarrer si le feu est vert
                }
            }

            // Vérification de la distance de sécurité par rapport aux usagers arrêtés
            // Vérification de la distance de sécurité par rapport aux usagers arrêtés
            for (const auto& autre_usager : usagers) {
                // Utilisation de get() pour obtenir un pointeur brut vers l'objet Usager
                if (auto* usager_autre = dynamic_cast<UsagerHautVersBas*>(autre_usager.get())) {
                    // Si l'autre usager est déjà arrêté et à une position proche du feu
                    if (usager_autre->get_y_position() >= position_feu_critique_vertical1y - distance_securite &&
                        usager_autre->get_y_position() < position_feu_critique_vertical1y) {

                        // Si l'usager arrivant est trop proche de l'usager arrêté
                        if (usager_hv->get_y_position() < usager_autre->get_y_position()) {
                            // L'usager qui arrive doit s'arrêter ou ralentir
                            usager_hv->arreter();  // Arrêt de l'usager arrivant
                        }
                    }
                }
            }

        }


        usager.deplacer(1.0f);
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

void generer_usagers(std::vector<std::unique_ptr<Usager>>& usagers, std::vector<std::jthread>& threads,
    Traffic_light& feu, std::stop_token stop_token) {
    int id = 0;
    // Création initiale de quelques usagers
    usagers.push_back(std::make_unique<Bus>(id++));
    usagers.push_back(std::make_unique<Pieton>(id++));
    usagers.push_back(std::make_unique<Cycliste>(id++));
    usagers.push_back(std::make_unique<UsagerDroitVersGauche>(id++));
    usagers.push_back(std::make_unique<UsagerHautVersBas>(id++));
    usagers.push_back(std::make_unique<UsagerBasVersHaut>(id++));

    // Création des threads pour chaque usager initial
    for (auto& usager : usagers) {
        threads.emplace_back(gestion_usager, std::ref(*usager), std::ref(feu), stop_token, std::ref(usagers));
    }

    while (!stop_token.stop_requested()) {
        int type = rand() % 10;
        std::unique_ptr<Usager> new_usager;
        if (type == 0) {
            new_usager = std::make_unique<Pieton>(id++);
        }
        else if (type == 1 ) {
            new_usager = std::make_unique<Cycliste>(id++);
        }
        else if (type == 2) {
            new_usager = std::make_unique<UsagerDroitVersGauche>(id++);
        }
        else if (type == 3) {
            new_usager = std::make_unique<Bus>(id++);
        }
        else if (type >= 4 && type <=7) {
            new_usager = std::make_unique<UsagerHautVersBas>(id++);
        }
        else {
            new_usager = std::make_unique<UsagerBasVersHaut>(id++);
        }

        // Vérification de la position avant d'ajouter un nouvel usager
        bool position_valide = true;
        
        

        for (const auto& usager_exist : usagers) {
            float distance;
            if (new_usager->est_vertical() && new_usager->direction == Direction::Haut ) {
                distance = std::abs(new_usager->get_y_position() - usager_exist->get_y_position());
            }
            else if (new_usager->est_vertical() && new_usager->direction == Direction::Bas){
                distance = std::abs( usager_exist->get_y_position()- new_usager->get_y_position());

            }
            else {
                distance = std::abs(new_usager->get_position() - usager_exist->get_position());
            }
            
            if (distance < distance_securite) {
                position_valide = false;
                break;
            }
        }


        if (position_valide) {
            usagers.push_back(std::move(new_usager));
            threads.emplace_back(gestion_usager, std::ref(*usagers.back()), std::ref(feu), stop_token, std::ref(usagers));
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}

int main() {
    std::stop_source stopping;

    // Deux groupes de feux (horizontaux et verticaux)
    Traffic_light feu_horizontal(Traffic_color::red);
    Traffic_light feu_vertical(Traffic_color::red);

    // Thread pour gérer les cycles synchronisés
    std::jthread feu_thread(gestion_feux_synchro, std::ref(feu_horizontal), std::ref(feu_vertical), stopping.get_token());

    std::vector<std::unique_ptr<Usager>> usagers;
    std::vector<std::jthread> threads_usagers;
    std::jthread creation_thread(generer_usagers, std::ref(usagers), std::ref(threads_usagers),
        std::ref(feu_horizontal), stopping.get_token());

    sf::Texture texture_fond;
    if (!texture_fond.loadFromFile("C:\\Users\\mahe.boissonnet\\source\\repos\\TDs\\traffic_light\\image\\route.jpg")) {
        std::cerr << "Erreur : Impossible de charger l'image de fond\n";
        return -1;
    }
    sf::Sprite sprite_fond(texture_fond);

    sf::RenderWindow window(sf::VideoMode(800, 600), "Simulation");
    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event))
            if (event.type == sf::Event::Closed) {
                stopping.request_stop();
                window.close();
            }

        window.clear();
        dessiner_fond(window, sprite_fond);

        // Dessin des feux synchronisés
        dessiner_feu(window, position_feu_critique1, 380.0f, feu_horizontal);
        dessiner_feu(window, position_feu_critique2, 180.0f, feu_horizontal);
        dessiner_feu(window, position_feu_critique_vertical1, 120.0f, feu_vertical);
        dessiner_feu(window, position_feu_critique_vertical2, 440.0f, feu_vertical);

        // Dessin des usagers
        dessiner_usagers(window, usagers);
        window.display();
    }

    return 0;
}
